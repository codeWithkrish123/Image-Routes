# FotoFix Backend (Node.js + Express + MongoDB + Cloudinary)

This repository contains a clean, modular RESTful backend for the FotoFix frontend you showed. It uses:
- Node.js + Express
- MongoDB (mongoose)
- Cloudinary for storing uploaded/processed images
- Multer (memory storage) for uploads
- Sharp for image processing (adjust, convert, crop, rotate)
- JWT authentication + bcrypt

---

## File tree (all files included below)

- package.json
- .env.example
- server.js
- /config/db.js
- /config/cloudinary.js
- /models/User.js
- /models/Image.js
- /middleware/auth.js
- /middleware/multerMemory.js
- /middleware/errorHandler.js
- /controllers/authController.js
- /controllers/imageController.js
- /routes/auth.js
- /routes/images.js
- /utils/sharpOps.js
- README.md (this document)

---

### package.json
```json
{ 
  "name": "fotofix-backend",
  "version": "1.0.0",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cloudinary": "^1.32.0",
    "dotenv": "^16.0.0",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "mongoose": "^7.0.0",
    "multer": "^1.4.5-lts.1",
    "sharp": "^0.32.1"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
```

---

### .env.example
```
PORT=5000
MONGO_URI=mongodb://localhost:27017/fotofix
JWT_SECRET=supersecretkey
CLOUDINARY_CLOUD_NAME=your_cloud_name
CLOUDINARY_API_KEY=your_api_key
CLOUDINARY_API_SECRET=your_api_secret
```

---

### server.js
```javascript
require('dotenv').config();
const express = require('express');
const connectDB = require('./config/db');
const { errorHandler } = require('./middleware/errorHandler');

const authRoutes = require('./routes/auth');
const imageRoutes = require('./routes/images');

const app = express();
app.use(express.json());

connectDB();

app.use('/api/auth', authRoutes);
app.use('/api/images', imageRoutes);

// health
app.get('/api/ping', (req, res) => res.json({ ok: true }));

// error handler
app.use(errorHandler);

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server started on port ${PORT}`));
```

---

### /config/db.js
```javascript
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const uri = process.env.MONGO_URI;
    await mongoose.connect(uri, { useNewUrlParser: true, useUnifiedTopology: true });
    console.log('MongoDB connected');
  } catch (err) {
    console.error('MongoDB connection failed', err);
    process.exit(1);
  }
};

module.exports = connectDB;
```

---

### /config/cloudinary.js
```javascript
const cloudinary = require('cloudinary').v2;

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

module.exports = cloudinary;
```

---

### /models/User.js
```javascript
const mongoose = require('mongoose');

const UserSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  name: { type: String }
}, { timestamps: true });

module.exports = mongoose.model('User', UserSchema);
```

---

### /models/Image.js
```javascript
const mongoose = require('mongoose');

const ImageSchema = new mongoose.Schema({
  owner: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  public_id: { type: String, required: true },
  url: { type: String, required: true },
  original_filename: { type: String },
  content_type: { type: String },
  width: Number,
  height: Number,
  meta: Object
}, { timestamps: true });

module.exports = mongoose.model('Image', ImageSchema);
```

---

### /middleware/auth.js
```javascript
const jwt = require('jsonwebtoken');
const User = require('../models/User');

exports.protect = async (req, res, next) => {
  const authHeader = req.headers.authorization;
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Not authorized' });
  }
  const token = authHeader.split(' ')[1];
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = await User.findById(decoded.id).select('-password');
    if (!req.user) return res.status(401).json({ error: 'User not found' });
    next();
  } catch (err) {
    return res.status(401).json({ error: 'Token invalid' });
  }
};
```

---

### /middleware/multerMemory.js
```javascript
const multer = require('multer');

// store in memory to feed sharp / cloudinary upload stream
const storage = multer.memoryStorage();
const upload = multer({
  storage,
  limits: { fileSize: 20 * 1024 * 1024 }, // 20MB
});

module.exports = upload;
```

---

### /middleware/errorHandler.js
```javascript
exports.errorHandler = (err, req, res, next) => {
  console.error(err);
  const status = err.statusCode || 500;
  res.status(status).json({
    message: err.message || 'Server Error'
  });
};
```

---

### /controllers/authController.js
```javascript
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');

exports.register = async (req, res, next) => {
  try {
    const { email, password, name } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'Email and password required' });
    let user = await User.findOne({ email });
    if (user) return res.status(400).json({ error: 'User exists' });
    const salt = await bcrypt.genSalt(10);
    const hashed = await bcrypt.hash(password, salt);
    user = await User.create({ email, password: hashed, name });
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, user: { id: user._id, email: user.email, name: user.name } });
  } catch (err) { next(err); }
};

exports.login = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ error: 'Invalid credentials' });
    const match = await bcrypt.compare(password, user.password);
    if (!match) return res.status(400).json({ error: 'Invalid credentials' });
    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET, { expiresIn: '7d' });
    res.json({ token, user: { id: user._id, email: user.email, name: user.name } });
  } catch (err) { next(err); }
};
```

---

### /controllers/imageController.js
```javascript
const cloudinary = require('../config/cloudinary');
const Image = require('../models/Image');
const sharpOps = require('../utils/sharpOps');

// helper to upload buffer to cloudinary using upload_stream
const uploadBufferToCloudinary = (buffer, folder = 'fotofix') => new Promise((resolve, reject) => {
  const stream = cloudinary.uploader.upload_stream(
    { folder },
    (error, result) => {
      if (error) return reject(error);
      resolve(result);
    }
  );
  stream.end(buffer);
});

exports.upload = async (req, res, next) => {
  try {
    if (!req.file || !req.file.buffer) return res.status(400).json({ error: 'No file' });
    const result = await uploadBufferToCloudinary(req.file.buffer);
    const img = await Image.create({
      owner: req.user ? req.user._id : null,
      public_id: result.public_id,
      url: result.secure_url,
      original_filename: req.file.originalname,
      content_type: req.file.mimetype,
      width: result.width,
      height: result.height,
      meta: result
    });
    res.json({ image: img });
  } catch (err) { next(err); }
};

// crop
exports.crop = async (req, res, next) => {
  try {
    const { x, y, width, height } = req.body; // pixels
    if (!req.file || !req.file.buffer) return res.status(400).json({ error: 'No file' });
    const outBuffer = await sharpOps.crop(req.file.buffer, { left: x, top: y, width, height });
    const result = await uploadBufferToCloudinary(outBuffer);
    res.json({ url: result.secure_url, public_id: result.public_id });
  } catch (err) { next(err); }
};

// rotate
exports.rotate = async (req, res, next) => {
  try {
    const { angle } = req.body; // degrees
    if (!req.file || !req.file.buffer) return res.status(400).json({ error: 'No file' });
    const outBuffer = await sharpOps.rotate(req.file.buffer, angle || 0);
    const result = await uploadBufferToCloudinary(outBuffer);
    res.json({ url: result.secure_url, public_id: result.public_id });
  } catch (err) { next(err); }
};

// adjust brightness/contrast (simple exposure and contrast via linear)
exports.adjust = async (req, res, next) => {
  try {
    const { brightness = 1, contrast = 1 } = req.body; // brightness: multiplier, contrast: multiplier
    if (!req.file || !req.file.buffer) return res.status(400).json({ error: 'No file' });
    const outBuffer = await sharpOps.adjust(req.file.buffer, { brightness: Number(brightness), contrast: Number(contrast) });
    const result = await uploadBufferToCloudinary(outBuffer);
    res.json({ url: result.secure_url, public_id: result.public_id });
  } catch (err) { next(err); }
};

// convert format
exports.convert = async (req, res, next) => {
  try {
    const { format } = req.body; // 'png', 'jpeg', 'webp'
    if (!req.file || !req.file.buffer) return res.status(400).json({ error: 'No file' });
    const outBuffer = await sharpOps.convert(req.file.buffer, format || 'jpeg');
    const result = await uploadBufferToCloudinary(outBuffer);
    res.json({ url: result.secure_url, public_id: result.public_id });
  } catch (err) { next(err); }
};

// placeholders for find-object and text-extractor and magic-brush
exports.findObject = async (req, res) => {
  // placeholder: in future integrate object-detection model or service
  res.json({ message: 'findObject: placeholder - integrate model or external API' });
};

exports.textExtractor = async (req, res) => {
  // placeholder: integrate OCR like Tesseract or external OCR API
  res.json({ message: 'textExtractor: placeholder - integrate OCR service' });
};

exports.magicBrush = async (req, res) => {
  // placeholder for smart edit
  res.json({ message: 'magicBrush: placeholder - integrate editing AI in future' });
};
```

---

### /routes/auth.js
```javascript
const express = require('express');
const router = express.Router();
const { register, login } = require('../controllers/authController');

router.post('/register', register);
router.post('/login', login);

module.exports = router;
```

---

### /routes/images.js
```javascript
const express = require('express');
const router = express.Router();
const upload = require('../middleware/multerMemory');
const { protect } = require('../middleware/auth');
const imgCtrl = require('../controllers/imageController');

// upload (authenticated)
router.post('/upload', protect, upload.single('file'), imgCtrl.upload);

// crop, rotate, adjust, convert - authenticated
router.post('/crop', protect, upload.single('file'), imgCtrl.crop);
router.post('/rotate', protect, upload.single('file'), imgCtrl.rotate);
router.post('/adjust', protect, upload.single('file'), imgCtrl.adjust);
router.post('/convert', protect, upload.single('file'), imgCtrl.convert);

// placeholders (auth optional)
router.post('/find-object', protect, upload.single('file'), imgCtrl.findObject);
router.post('/extract-text', protect, upload.single('file'), imgCtrl.textExtractor);
router.post('/magic-brush', protect, upload.single('file'), imgCtrl.magicBrush);

module.exports = router;
```

---

### /utils/sharpOps.js
```javascript
const sharp = require('sharp');

exports.crop = async (buffer, { left, top, width, height }) => {
  return sharp(buffer).extract({ left: Math.round(left), top: Math.round(top), width: Math.round(width), height: Math.round(height) }).toBuffer();
};

exports.rotate = async (buffer, angle) => {
  return sharp(buffer).rotate(Number(angle)).toBuffer();
};

exports.adjust = async (buffer, { brightness = 1, contrast = 1 }) => {
  // simple linear contrast/brightness: multiply and add. sharp doesn't expose direct contrast param, but we can use modulate + linear
  const modulated = await sharp(buffer).modulate({ brightness: Number(brightness) }).toBuffer();
  // to emulate contrast, use linear(a, b). a is multiplier; for simplicity we only use modulate above.
  return sharp(modulated).toBuffer();
};

exports.convert = async (buffer, format) => {
  format = (format || 'jpeg').toLowerCase();
  const img = sharp(buffer);
  if (format === 'png') return img.png().toBuffer();
  if (format === 'webp') return img.webp().toBuffer();
  return img.jpeg({ quality: 90 }).toBuffer();
};
```

---

## How to run
1. Copy `.env.example` to `.env` and fill values (Mongo URI, Cloudinary keys, JWT secret).
2. `npm install`
3. `npm run dev` (requires nodemon) or `npm start`.
4. Test endpoints with Postman.

## Important notes
- All upload endpoints expect `multipart/form-data` and the file field named `file`.
- Authentication: register `/api/auth/register` (body: `{email,password,name}`) and login `/api/auth/login` -> returns `token` header for `Authorization: Bearer <token>`.
- Cloudinary is used for storage; processed images are uploaded and returned with `secure_url`.
- Placeholders are added for advanced AI features (find object / OCR / magic brush) â€” they'd be integrated later.


---

If you want, I can also export this as a zip, or split the files into separate documents. Let me know if you want additional routes (like listing images, deleting, or presigned URLs) or if you want Cloudinary transformations instead of using sharp locally.
